local version = "v1.62 04-04-2020"	-- @CybrMage @macrho @djrobx @BOFH @kornev @JoeyD @CAB426"

local PLUGIN_CONFIG = {
	WEB_MODE_DISABLED					= false,					-- debug option - disable web mode fallback - normally false
	API_MODE_DISABLED					= false,					-- debug option - disable api mode - normally false
	FORCE_DEBUG								= false,					-- debug option - override user configured debug_mode - normally false
	WEB_MODE									= false,
	WEB_LOGIN									= false,
	DEBUG_MODE								= false,
	UI7_GDO										= false,
	ENHANCED_STATUS						= false,
	USERNAME									= "",
	PASSWORD									= "",
	MYQ_API_VERSION						= "4.1",
	MYQ_APP_VERSION						= "3.88.30470",
	SecurityToken							= "",
	BASE_URL									= "",
	VALIDATION_URL						= "",
	GET_DEVICE_ATTR_URL				= "",
	SET_DEVICE_ATTR_URL				= "",
	USER_DEVICE_DETAILS_URL		= "",
	USER_DATA_URL							= "",
	APPID											= "",
	BRAND											= "",
	NAME											= "MyQGateway"
}

local MyQGatewayID = nil -- Device ID

-- Version 1.6	: Jan 18, 2015.					Changes the device icon to reference app store icon.  (Currently 50x50, so the icon
--																			fits well in UI5, though it's a bit blurry when expanded in the App store an in UI7.
--																			Tweaked the myQ Setup tab to work around a UI5 bug.
-- Version 1.8	: Feb 1, 2015.					Will exclude garage door openers if certain parameters are set.  Needed
--																			for the WiFi hubs that support more than one opener, but only one openers
--																			is paried with it.
-- Version 1.11B1	: January 31, 2017.		Minor bug fixes, updated AppIDs, updated craftsman url, tweaked GDO device detection, 
--																			addition of DEBUG_MODE, addition of UI7_GDO option to use Binary light subcategory 5 to 
--																			display the opener devices as garage doors.
-- Version 1.12	: February 4, 2017.			Refactoring due to deprecation of previous API version

-- Libraries

local https = require("ssl.https")
local url = require("socket.url") -- Guessed suggestion for un/pw encoding

-- Constants for guessed's code
local TASK_ERROR = 2
local TASK_ERROR_PERM = -2
local TASK_SUCCESS = 4
local TASK_BUSY = 1
local MSG_CLASS = "MyQ Gateway"
local taskHandle = -1

local MYQGATEWAY_SID = "urn:macrho-com:serviceId:MyQGateway1"
local GDO_SID = "urn:micasaverde-com:serviceId:DoorLock1"
local BINARY_LIGHT_SID = "urn:upnp-org:serviceId:SwitchPower1"

-- CONSTANTS for TypeIds in the Devices list
-- NOTE: The Mobile App shows other devices: Remote Light, Gate Operator as I don't have these, I'm ignoring them
-- Based on inspecting mychamberain.com (Scripts/ChamberlainConstants.js)  the following device IDs are possible:
-- GDO=47, light=48, gateway=49, gate=52, cdo=264, vgdo=259.  Not sure what "cdo" and "vgdo" are exactly, but will treat those like
-- standard garage doors

-- TypeIds seem to be deprecated in favor of MyQDeviceTypeIds
local GARAGE_DOOR_OPENER = { 47,52,264,259,1012 } --Appears that 47 isn't the only TypeId for a garage door, this will likely need to be expanded
local LIGHT_SWITCH_DEVICE = {48}
local GATEWAY_DEVICE = {49,1011}

local MyQDeviceTypeIds = {
	GATEWAY = {1,15,16},
	OPENER = {2,5,7,9,17},
	LIGHT = {3},
	NEST = {10},
	THERMOSTAT = {11},
	CAMERA = {13}
}

local UTIL = {
	-- Function found: http://lua-users.org/wiki/StringRecipes
	-- Used to encode username / password for submission
	url_encode = function(self, str)
		if (str) then
			str = string.gsub(str, "\n", "\r\n")
			str = string.gsub(str, "([^%w %-%_%.%~])", function(c) return string.format("%%%02X", string.byte(c)) end)
			str = string.gsub(str, " ", "+")
		end
		return str
	end,

	setVariableDefault = function(self, SID, variable, default, Device)
		if (type(default) == "boolean") then if (default) then default = "1" else default = "0" end end
		if (variable == nil) then return end
		if (SID == nil) then return end
		local cValue = luup.variable_get(SID, variable, Device)
		if ((cValue == nil) or ((cValue == "") and (default ~= nil))) then luup.variable_set(SID, variable, default, Device) end
	end,

	-- Function to return the number of elements in the index of a table.
	ubound = function(self, T)
		local count=0
		for k,v in pairs(T) do count=count+1 end
		return count
	end,

	-- Thanks to RichardTSchaefer  for providing this useful function to "dump" the contents of a variable / table.
	-- Will be used to dump the attributes of unknown myq devices when encountered.
	dump = function(self, o, levels, nofunc)

	   local nlevels
	   if (levels) then
		  nlevels = levels - 1
	   end
	   local ot = type(o)
	   if ot == 'table' then
		  local s = '{ '
		  for k,v in pairs(o) do
			 if type(k) ~= 'number' then k = '"'..k..'"' end
			 local r
			 if (levels) then
				if ((levels > 0) or (type(v) ~= "table"))  then
				   r = self:dump(v, nlevels, nofunc)
				else
				   r = "*" .. type(v) .. "*"
				end
			 else
				r = self:dump(v, levels, nofunc)
			 end
			 s = s .. '['..k..'] = ' .. r .. ','
		  end
		  return s .. '} '
	   else
		  if (nofunc and (ot == 'function')) then
			 return("*f")
		  else
			 return tostring(o)
		  end
	   end
	end,

	getTimestamp = function(self)
		return os.date("%a %b %d %Y, %X")
	end,

	IsUI7 = function(self)
		if ((tonumber(luup.version_branch,10) == 1) and (tonumber(luup.version_major,10) == 7)) then return true else return false end
	end,

	sanitizeText = function(self, text)
		if (PLUGIN_CONFIG.USERNAME and (PLUGIN_CONFIG.USERNAME ~= "")) then
			text = text:gsub(PLUGIN_CONFIG.USERNAME,"********")
		end
		if (PLUGIN_CONFIG.PASSWORD and (PLUGIN_CONFIG.PASSWORD ~= "")) then
			text = text:gsub(PLUGIN_CONFIG.PASSWORD,"********")
		end
		return text
	end,

	shellExecute = function(self, cmd, Output)
		if (Output == nil) then Output = true end
		local file = assert(io.popen(cmd, 'r'))
		if (Output == true) then
			local cOutput = file:read('*all')
			file:close()
			return cOutput
		else
			file:close()
			return
		end
	end

}

local function debug(text,level, forced)
	if (forced == nil) then forced = false end
	if ((PLUGIN_CONFIG.DEBUG_MODE == true) or (forced == true)) then
		-- sanitize the debug text
		text = UTIL:sanitizeText(text)
		if (#text < 7000) then
			if (level == nil) then
				luup.log((text or "NIL"))
			else
				luup.log((text or "NIL"), level)
			end
		else
			-- split the output into multiple debug lines
			local prefix_string = ""
			local _,debug_prefix,_ = text:find("): ")
			if (debug_prefix) then
				prefix_string = text:sub(1,debug_prefix)
				text = text:sub(debug_prefix + 1)
			end
			while (#text > 0) do
				local debug_text = text:sub(1,7000)
				text = text:sub(7001)
				if (level == nil) then
					luup.log((prefix_string..(debug_text or "NIL")))
				else
					luup.log((prefix_string..(debug_text or "NIL")),level)
				end
			end
		end
	end
end

--Utility function to prefix MSG_CLASS to all log calls
function log(message,msgLevel)
	if (msgLevel ~= nil) then debug(message,msgLevel,true) else debug(message,nil,true) end
end


local json = {
	jsonx = require("L_MyQGateway_json"),
	encode = function(self, data) return self.jsonx.encode(data) end,
	decode = function(self, data)
		if (data:sub(1,5) == "<html") then
			debug("(MyQGateway::json.decode): Invalid json data!",1)
			return {ReturnCode = "1"}
		else
			return self.jsonx.decode(data)
		end
	end
}


-- These should not change but who knows, follow UPPERCASE convention for names

local BRANDING = {
	["Chamberlain"] = {
		APPID = "Vj8pQggXLhLy0WHahglCD4N1nAkkXQtGYpq2HrHD7H1nvmbT55KqtN6RSF4ILB/i",	-- android Chamberlain appid - v3.73
		BASE_URL = "https://myqexternal.myqdevice.com/"
	},
	["Liftmaster"] = {
		APPID = "NWknvuBd7LoFHfXmKNMBcgajXtZEgKUh4V7WNzMidrpUUluDpVYVZx+xT4PCM5Kx",	-- android Liftmaster appid - v3.73
		BASE_URL = "https://myqexternal.myqdevice.com/"
	},
--	["Merlin"] = {
--		APPID = "unknown", -- android craftsman appid - v3.70.1
--		BASE_URL = "https://myqexternal.myqdevice.com/"
--	},
	["Craftsman"] = {
		APPID = "eU97d99kMG4t3STJZO/Mu2wt69yTQwM0WXZA5oZ74/ascQ2xQrLD/yjeVhEQccBZ", -- android craftsman appid - v3.73
		BASE_URL = "https://myqexternal.myqdevice.com/"
	}
}

local SecurityToken = "[not set]" -- Used for accessing the MyQ Service

local DEVICE_ICONS = {
	DATA = {
		["MyQ_garage_offline.png"] = "89504E470D0A1A0A0000000D494844520000003C0000003C08030000000D222940000000017352474200AECE1CE90000000467414D410000B18F0BFC610500000300504C5445000000B55C5DA86E6FA47373A47374A77576AF7E7EDB2C2CDE2828D43535D53536D53737D83131DB3C3CF70808FA0404FF0000FE0202FE0303F80909FA0B0BFE0808FE0C0CFE0E0EF31414F01A1AFE1010FE1212FE1818FD1A1AF22323FE2020FE2828FD2F2FFE3030FE3838DF3F40C44B4BD54D4ECA6161E04141E24243E54647F24B4BFE4040FE4848FE4A4AFD4F4FFE5050FE5454FE5858FD5E5EFD5F5FFE6060FE6868FE7070FE7878FF7F7FB17F8093898A908E8F918F909290919391929492939593949795969997989A98999C9A9B9D9B9C9D9C9DA09E9FBC8B8BB99090A09FA0A2A0A1A3A1A2A7A5A6A9A7A8ADABACAEACADAFAEAFB2A0A1B0AEAFB5ACACBAA1A1B1B0B0B1B0B1B2B1B2B4B3B3B7B6B6BBBABBBCBBBCBDBCBCBEBCBDBFBDBEBFBEBEBFBEBFCA999ACC9B9CC1C0C0C4C3C4C5C4C4C5C4C50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009EC7A8B80000010074524E53FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0053F70725000000097048597300000EC300000EC301C76FA8640000001A74455874536F667477617265005061696E742E4E45542076332E352E313030F472A10000035449444154484BCD97697FD2401087BD6FCBA8C503516AEB2D28A250D0057ADA6A95D28A96DA5BADF6FB7F8138333B9BEC261BC09F6FFCBF08B3D979B293C964331C0BFE41FF1F5C2F66C1A8382D27E3F2C2150D165939B64B32E5C80317D077AA2E032D0A23E79E2225605C68424C475300D986D84631B8888B8A995039715917CE415E2CAF2600C4D2B2E1064045CC14D5DDCC597015B2620D50CEBEAD08AE424EAC417A0E3029A605D74662AB70E34E1479088F12B38E2E07A6E20C9C75F3E897DC59E82BF06478B5010AB3621EA8C056162C6D28B52126AA1266A50C55FED5B02FE8C365A5DA6DA5960FF5D87E1AE2CFF034947960A9338B6853A926E2B31D3CE13CC9BA06188E2FFC6D8630A5968260898DE6CC139B3504C3EEC2EFD85FCDF6F4B08731A80B3076460FB5A6B990099EB416DE6971A4331469A8CE45183BDD54AD1D19A3B82C088E5EA555A55A94A3EF7AB8B7D2E5DF2A8CBFC114B4945AE531AA480B32AC13BFB680283AACF38884F192F76BBEDF753DBBB0C6530C215CA68B1CCCD37DE2E58FF41CE9178E3F59793E4216D59C3FC0011418CE43D0D7396A2AED65B4A8DABF655D91B8A93E5638C378EFDB74623101935E39CF085D1689DEC63D4DC3589A6A6E0B0FAD24ECD486B86CCDE1A122B0793F559BE0DDFDBD484F61FC8798FBBBA10BA9010D8675B265062B3AD279183B25266A7928BC229E24644F8A495AF99B95DD75535636951D83E3AC1F369BA90B275817AE49B64D693B709275E19286A9565836EC615DB8A0617E414811FCD6C7BA30150FC20DB37386F0DB733E3606639A110ECC973384CF7A5907AE52B804E36BC532B03766940DF32646705DE216388D756028E28160F39DD2702A6BC37ADB63B8AC97E699CBA9ACFA18C1BA36180E20F3B5BFD9C1F9DEE3741637E31E1E3B9BFD2FB7749634FC0C2EE9F9F4986D3D80BB8C6938C8C0713A3B1A7B22033F9912F811643E74BBF7E1DAFBEE507DBE090F3525303EF4427CBF4A53297C0D0D1CDC83DBA3B12F22B7100EAEC355B1062AFAC4DBF0CB2BFEA6D355C90E2F82A96C86C65D705C6C985AD381FD23768F4EEFE2C0F4B2E4E27D71A43C80DB73C760BC275F574EC21E3EDE4DC7616EB9933D375ED393CE248C05437F2BF2C56A83552BD2FF066F327C30AA867D79A482F9A6C49402B3F4CA32F069103C4441F007230BF83CF0A254520000000049454E44AE426082",
		["MyQ_garage_opening.png"] = "89504E470D0A1A0A0000000D494844520000003C0000003C08030000000D222940000000017352474200AECE1CE90000000467414D410000B18F0BFC610500000300504C5445000000AE7075AE7B7FF6283AED3141EC3242ED3443ED3646ED3C4BEE3E4DEF4B59EF4E5CEF4F5DEF505EEE525FFA4A59F16773F26B77F2707B8F8F908E9090928B8C918C8D928D8F908E8F918F909290919391929492939593949795969997989A98999C9A9B9D9B9C9D9C9DAE8C8EA09E9FA19FA0A3A1A2A6A5A5A7A5A6A8A7A8ACAAABADABACAEACADAEADAEAFAEAFB2ADAFB0AEAFB1B0B0B2B0B1B2B1B2B3B2B3B4B2B3B7B6B6BBBABBBCBBBCBEBDBDBFBEBEBFBEBFF4828CF4858EF4868FF38790F48790F38C95F48891F48C95FF8590F5949CC1C0C0C2C0C1C4C3C4C5C4C4C5C4C500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000013E4989B0000010074524E53FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0053F70725000000097048597300000EC300000EC301C76FA8640000001A74455874536F667477617265005061696E742E4E45542076332E352E313030F472A1000001CA49444154484BED94D952C24010455D82A8A8A808761250710F8A8241DCC00D77FFFF7BC69ECC0D6643266559BEE43C40DF9E3E613245CD84F805999C924C4E4926A7E447F98CE80C6522A3E5D73D22DB26DA7B4523CE28D9A9B16A1299ACD71C34A324CADDAAD4887684D8F10AB3DAC552880479DB9BA75A5BC536EF4136B6550C1295AF2C6FA7D5D04E9DAAF70ED615B24F586E1059F28C7A2A5EEF1FAB42F4E4E959440D6445406E6EB1CA03A7C842F07EBFA74FD5EA561399F1E59B4DF99EFCF84F349877CE07A8259FEC32E6E60D1A4A76D51999E4A52175B23F50028C91EB25255FCA463D26C7E191BAB42FBD846DD3C6057F58E3653972B181B9C08109B265F376F0E073777F8F8A19DC0E477C6272C1307289184661ACBC68E4678794F12DC91B8B1A721F5108DBB651317D2DF90951BA01FB494B5E465C572089652D7926EF532E975131337F2FAF200A619A262A66454B7E418C9CF68B963CBFEA53A9545031F31AF2823192058D5FCECF25A2F30F5BCA3D224678CC2D8D958BD3CF88119EA78B23E4A3AEDB71F89268B7A626775DB713C3757727A75A6D1E713AEE39EE31C8DC04A5B512AA08A18537CF8AC97A84E4C393E314347121070F2C35999C924C4EC97FC9427C015F7E50A0871971890000000049454E44AE426082",
		["MyQ_garage_closing.png"] = "89504E470D0A1A0A0000000D494844520000003C0000003C08030000000D222940000000017352474200AECE1CE90000000467414D410000B18F0BFC610500000300504C5445000000FF0000908E8F918F909290919391929492939593949795969997989A98999C9A9B9D9B9C9D9C9DA09E9FA09FA0A2A0A1A3A1A2A6A5A5A7A5A6A8A7A8ACAAABADABACAEACADAEADAEAFAEAFB0AEAFB1B0B0B1B0B1B2B1B2B3B2B3B4B2B3B7B6B6BBBABBBCBBBCBDBCBCBEBCBDBFBDBEBFBEBEBFBEBFC1C0C0C2C0C1C4C3C4C5C4C4C5C4C500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B209780000010074524E53FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0053F70725000000097048597300000EC300000EC301C76FA8640000001A74455874536F667477617265005061696E742E4E45542076332E352E313030F472A10000015E49444154484BED94D97682301086CBB0A928D862A5462CEEDAD6F77FBD74920C96258839DD6EF25D70E69FCC27493C8707FE0DAC6C88950DB1B22137E525C0924A2DDDF23906F07D80F84C8D365D721AA2EA02B8A88729359B68E522101AC084F3892CDCA0A0A51A1A792CE721642A32DC83688C55ACD294B79EDC6950DB691AC833785BCA25757906E0893B3AA9B84FE6AAE027717B1EC08CB2A2226723547160419973DCEFD7F442AD8E32CA48291F87E29CF8F3176A20EF981FA9165CD045DCE1911A4ACED51DB920D39508FC0F2A091A835C26256F44236AC96D702412F64626DA360CD6F8F0FA6531B21ED05CE5C238F8A2B93BECB51C76D79192968CFF491771AF9CD0A486E477DF5C951DC7A14A6265E4868CAA801262F4E686FB9767869A6B2AD7E997A734A961DA213F17F92AC575263FB41D848CE1335DE5AFF41D2359ADDECF9BB47E427E7A991B90D107B97A61C658D9102B1BF25F32E79F936A94C2625F56C70000000049454E44AE426082",
		["MyQ_garage_stopped.png"] = "89504E470D0A1A0A0000000D494844520000003C0000003C08030000000D222940000000017352474200AECE1CE90000000467414D410000B18F0BFC610500000300504C5445000000ED3141ED3242ED3443ED3646ED3C4BEF4B59EF4E5CEF505EF16773F26B77F2707B908E8F918F909290919391929492939593949795969997989A98999B999A9C9A9B9D9B9C9D9C9DA09E9FA19FA0A1A0A1A3A1A2A6A5A5A7A5A6A8A7A8ACAAABADABACAEACADAEADAEAFAEAFB2ADAFB0AEAFB1B0B0B1B0B1B2B1B2B3B2B3B4B2B3B7B6B6BBBABBBCBBBCBEBDBDBFBEBEBFBEBFF4828CF4858EF4868FF38790F48790F48891F48C95F5949CC1C0C0C2C0C1C4C3C4C5C4C4C5C4C5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C2EFC60B0000010074524E53FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0053F70725000000097048597300000EC300000EC301C76FA8640000001A74455874536F667477617265005061696E742E4E45542076332E352E313030F472A10000018D49444154484BED946953C2301086AD2097DB831B448B209422871C2287CAFFFF5771D36CB19454D251C62F7D3E74F6DDECD34933D35CB15F90C83149E49824724C7E940700032AA544CBBB268069023477D438254AB68BA8EA003AEA459B9A61A4F2C8E21A4083B18657E8D688968E90C8756F1E8A8E880EEE8137EA220609CB53C3DBA975B453DBF2BEC19852F63996DB00063FA3B9882F771D51B0393F3D03A04D591090BB155471A0479931DCEFF7744FAC56BA94115F9E95F977E2EBF7D4403E30DF53CDD9A38BE8E5193584EC8A33D2C14B076A607E5249D018B85E12F284376A27F2293852E3F6C44BB46D288DF1619C97F9C8B8447381036360F2E672FDE6F3BA5A5185AC9787119F1339AB69D752342D7B56CE69E91B29692DA7202F28865828C91B8A21364A729E6288BC929C4A4B495D5E2E500C515092B714436C95E4CCAD948C828C7F7D14CDCBCA2D9A94D03A2B5769524235427E1CB9431BD79D3EDE7F51987D079FF6D07DA67B8C64B1AACEBB67FD85FCF0D48941972EE4E081C526916392C831F92F99B12FE8881DBCE709C2490000000049454E44AE426082",
		["MyQ_garage_faulted.png"] = "89504E470D0A1A0A0000000D494844520000003C0000003C08060000003AFCD972000000017352474200AECE1CE90000000467414D410000B18F0BFC6105000000097048597300000EC300000EC301C76FA8640000001A74455874536F667477617265005061696E742E4E45542076332E352E313030F472A10000044A494441546843ED983BA81C5518C7AF79AA21A821962101E11696512162912EA40BD1C242126CD259588B766AA3C43791D4762A1A515111BB086AA7041F8D8A852288E2FB7DFDFD86EF5BCFCE3D7B77EFBDD98459CE1F7EEC7C67CEF7DA39737676969A9A9A9A9A9A9A9A9A9A266B6565658C8555BFD13E0BA75A93250BA55A83352EBB1E3FFDD816D8166C89E175ABD65C8DCB2E9ADC01D7063B6278DDAA3557E392A97FF5B0F7C1EDF00AAC041E3BB62FA675C29E7AE56BCDD598AB2C14B687D909FB089C86CF201BFD2D48DB73CE39126E9DB0B7C3C4E66B0D8EB3FFCA987A716551B0334CEDDD703FBC073F42D9E8DF85ED71D9B873F5D177778433DE4E58D578BDC9FFB9E8B208D816A6F621781E7E81B2B1BFE0DF38FE1C4E051E3BE639E7E47C7D8D61AC4311DEF8D58D6E75B3F3BBB25B610FDC0D5F42165C16FF0F78E55E839BC37524C66E8A73CE716E2DC617600E736D0DD7F98924574898DA7BE1303C0B7F8045F597E7CFF03EDC07D787ABBE57C101D8137677C59C03CED547DF8C53DE06E632A7B9F7EAA7381EAB6F438A20634B88E383E0FD751EB2A03FE1D7C276037A028E865B276C97FF75F0347C0C6FC36D716E74FF2BECA3608C72A33387B9D2B6066B39186E99C39AD7D73C0EEE8EA3A5C3F109780BBE864C68F2BCBAF23A1C8703E1D609DB22BA02F8BC1772BE9CEF26218EFD82C7EE4F6C5782318D9D3EE62C1BB7266B3B116EFA79AB8DFD5A4C150E2EB127E15B28EF27C90DE87778102C6C6A02E63C0CFAE5BDFA21EC8AD313C51C2FC07E30577EC95943628DD66ACDA35B6826E1700ECA4065F0BC9F4EC6F4FC46A76E26CC7117FF0A6CD82FEBA1185FB5F396E2FC587C8E4F42598BF477FA73317DBA987C369C32A0C12CB41C73F3D905DDF20797EE5A743F5F7CDE00F740778FF3E9A3666D7E9F6E998239CD5DD6626D795172ECACF167129397C3E93B780EEE82FC567349B901CDFF27A2277346EEB2166BB3466BB566C796C365BA986CD03BE146C80DE71818C8A5980D5F0D0FC019780ADC81A7F14C41ED7C0D639BC35CE6CC86B3966351A31B9F355BFBC62E8641E2D3DDB24CE243C03550FE74CC1B7399D3DCDA59CBF1B2D64D8920F96030A9E14FC27623F23E9A07B9AB9B6BAD86D7DCFC665206316804EF37FC69D816E6E73CC8D8E61A5EC32B3F2C77D4CE4D60980D67A37D6A737B0CAFE15A83B5B1092C4CC31FF5C72630AC86B3A97E731C7F531BAFB0300D57C72B0CAB61A935568E95E31586DD70F07D69D77C0A86D7B0F49B9BB159996FC338FA109E7FF9BAD73C700794497C41E043FCCC0D4B36B98E66A56CD89CE6D6CE5AACADACD5DA37F75C4D005F9C8D92C4B0E317627CA6863748C6BE1069CDAB9D0D1F8EE18D8900B7C03BF002BC0C2F812FC80D9E0FF2BE5A7D157E0AFB52602E739A5B3B6BB1366BB4D617E14D18BD91992A26E77FDF21F348B4335D4C5E84861F8D76A68BC9B7C207F006F8FE7848B89CDF8553D14ED32AF1EDE4CFD290D9FCEB9EA6A6A6A6A6A6A6A6A6A6495A5AFA0F7FB5980288C78AAD0000000049454E44AE426082"
	},
	file_exists = function(self,filename)
			local file = io.open(filename)
			if (file) then
				io.close(file)
				return true
			else
				return false
			end
		end,
	decode_hex_string = function(self,hexStr)
		if (not hexStr) then
			luup.log("MyQGateway::DEVICE_ICONS::decode_hex_string): No hex data supplied.",1)
			return nil
		end
		if (math.floor(#hexStr/2) ~= (#hexStr/2)) then
			luup.log("(MyQGateway::DEVICE_ICONS::decode_hex_string): Invalid hex data supplied.",1)
			return nil
		end
		luup.log("(MyQGateway::DEVICE_ICONS::decode_hex_string): input size ["..(#hexStr or "NIL").."].",2)
	  local i = 1
	  local hexStr_len = hexStr:len()
	  local VALUE = ""
	  while i <= hexStr_len do
	     local c = hexStr:sub(i,i+1)
	     VALUE = VALUE .. string.char(tonumber(c,16))
	     i = i + 2
	  end
		luup.log("(MyQGateway::DEVICE_ICONS::decode_hex_string): output size ["..(#VALUE or "NIL").."].",2)
	  return VALUE
	end,
	create_png = function(self,data,filename)
			-- data = hex encoded png file contents
			if (self:file_exists(filename)) then return false end
			local png_data = self:decode_hex_string(data)
			if (png_data and (#png_data == (#data/2))) then
				log("(MyQGateway::DEVICE_ICONS::create_png): writing PNG Data for file ["..(filename or "NIL").."]",2)
				local file = io.open(filename,"wb")
				if (file) then
					file:write(png_data)
					file:close()
					return true
				else
					return false
				end
			else
				log("(MyQGateway::DEVICE_ICONS::create_png): PNG Data DECODE ERROR",1)
				return false
			end
		end,
	createIcons = function(self, is_ui7)
			local fPath = "/www/cmh/skins/default/icons/"										-- UI5 icon file location
			if (is_ui7) then
				fPath = "/www/cmh/skins/default/img/devices/device_states/"		-- UI7 icon file location
			end
			for fName, fData in pairs(self.DATA) do
				if (not self:file_exists(fPath..fName)) then
					self:create_png(fData,fPath..fName)
				end
			end
		end
}	


-------------------------------------------------------------------
-- Thanks to guessed for sharing clearTask() and task(text,mode) --
-------------------------------------------------------------------
function task(text, mode)
  log("(MyQGateway::task): task [" .. text.."]")
  if (mode == TASK_ERROR_PERM) then
    taskHandle = luup.task(text, TASK_ERROR, MSG_CLASS, taskHandle)
  else
    taskHandle = luup.task(text, mode, MSG_CLASS, taskHandle)
    -- Clear the previous error, since they're all transient
    if (mode ~= TASK_SUCCESS) then
        luup.call_delay("clearTask", 30, "")
    end
  end
end

function clearTask()
  task("Clearing...", TASK_SUCCESS)
end


------------------------------------------------------------------------------------------------------------
--																																																				--
-- Connects to the LiftMaster/Chamberlain MyQ WEB API                                                     --
--																																																				--
------------------------------------------------------------------------------------------------------------
local WEB_LOGIN = {
	["Liftmaster"]	= {BrandName = "Liftmaster", BrandHost ="www.myliftmaster.com"},
	["Chamberlain"]	= {BrandName = "Chamberlain", BrandHost ="www.mychamberlain.com"},
	["Merlin"]			= {BrandName = "Merlin", BrandHost ="www.mymerlin.com.au"},
	["Craftsman"]		= {BrandName = "Craftsman", BrandHost ="assurelink.craftsman.com"}
}

WEB_API = {
	NAME = "WEB_API",
	TriggerStateChange = function(self, DeviceId,attributeName, attributeValue)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::TriggerStateChange): DEVICE ["..(DeviceId or "NIL").."] Attribute ["..(attributeName or "NIL").."] Value ["..(attributeValue or "NIL").."]")
		-- make sure the login tokens are fresh
		self:LoadSingleDevice(DeviceId)
		local BRAND_NAME = WEB_LOGIN[brand].BrandName
		local API_HOST = WEB_LOGIN[brand].BrandHost
		local DeviceCMD = "curl -k -b /tmp/MyQWebLogin_Cookies -c /tmp/MyQWebLogin_Cookies -X POST -s -H 'Content-Type: json' -H 'Content-Length: 0' -H 'Referrer: "..API_HOST.."/Dashboard' 'https://"..API_HOST.."/Device/TriggerStateChange?SerialNumber="..DeviceId.."&attributename="..attributeName.."&attributevalue="..attributeValue.."'"
		debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::TriggerStateChange): DeviceCmd: "..DeviceCMD)
		local RetVal = UTIL:shellExecute(DeviceCMD)
		debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::TriggerStateChange): RetVal: "..RetVal)
		if (RetVal:sub(1,1) == "{") then
			-- success
			return 1, RetVal
		else
			log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::TriggerStateChange): TRIGGER STATE CHANGE FAILED")
			return 0, "[{}]"
		end
	end,

	getDeviceList = function(self)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getDeviceList): GET DEVICES")
		local BRAND_NAME = WEB_LOGIN[brand].BrandName
		local API_HOST = WEB_LOGIN[brand].BrandHost
		local DeviceCMD = "curl -k -b /tmp/MyQWebLogin_Cookies -c /tmp/MyQWebLogin_Cookies -s -H 'Referrer: "..API_HOST.."/Dashboard' https://"..API_HOST.."/api/MyQDevices/GetAllDevices?brandName="..BRAND_NAME
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getDeviceList): getDeviceList CMD: "..DeviceCMD)
		local RetVal = UTIL:shellExecute(DeviceCMD)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getDeviceList): getDeviceList DEVICES: "..RetVal)
		if (RetVal:sub(1,2) == "[{") then
			-- success
			return 1, RetVal
		else
			if (RetVal:find("Authorization has been denied")) then
				PLUGIN_CONFIG.WEB_LOGIN = false
				if (self:DoLogin()) then
					return self:getDeviceList()
				end
			end
			log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getDeviceList): GET DEVICE LIST FAILED")
			return 0, "[{}]"
		end
	end,

	LoadSingleDevice = function(self, DeviceId)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::LoadSingleDevice): DEVICE ["..(DeviceId or "NIL").."]")
		local BRAND_NAME = WEB_LOGIN[brand].BrandName
		local API_HOST = WEB_LOGIN[brand].BrandHost
		local DeviceCMD = "curl -k -b /tmp/MyQWebLogin_Cookies -c /tmp/MyQWebLogin_Cookies -X POST -s -H 'Content-Type: json' -H 'Content-Length: 0' -H 'Referrer: "..API_HOST.."/Dashboard' 'https://"..API_HOST.."/api/MyQDevices/LoadSingleDevice?brandName="..BRAND_NAME.."&SerialNumber="..DeviceId.."'"
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::LoadSingleDevice): DeviceCmd: "..DeviceCMD)
		local RetVal = UTIL:shellExecute(DeviceCMD)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::LoadSingleDevice): RetVal: "..RetVal)
		if ((RetVal:sub(1,1) == "{") or (RetVal:sub(1,1) == "[")) then
			-- success
			return 1, RetVal
		else
			if (RetVal:sub(1,2) == "[]") then
				PLUGIN_CONFIG.WEB_LOGIN = false
				if (self:DoLogin()) then
					return self:LoadSingleDevice(DeviceId)
				end
			end
			log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::LoadSingleDevice): LOAD DEVICE FAILED")
			-- if we fail, the login tokens probably need a refresh
			return 0, "[{}]"
		end
	end,

	DoLogin = function(self)
		if (PLUGIN_CONFIG.WEB_MODE_DISABLED == true) then
			return false, "Web Login Disabled"
		end
		if (PLUGIN_CONFIG.WEB_LOGIN == true) then
			return true, "Login Success"
		end
		local USERNAME = PLUGIN_CONFIG.USERNAME
		local PASSWORD = PLUGIN_CONFIG.PASSWORD
		local API_HOST = WEB_LOGIN[brand].BrandHost
		if ((USERNAME == nil) or (USERNAME == "") or (PASSWORD == nil) or (PASSWORD == "")) then
			log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::DoLogin): response:  FAILED - Username or Password not set.")
			return false, "Web Login Failed - No username/password."
		end
	
		local LoginURL = "https://"..API_HOST
		local LoginCMD
		if (UTIL:IsUI7()) then
			LoginCMD = "rm /tmp/MyQWebLogin_Cookies;curl -b /tmp/MyQWebLogin_Cookies -c /tmp/MyQWebLogin_Cookies  -k -s -o /tmp/MyQWebLogin_Temp --next -d 'Email="..UTIL:url_encode(USERNAME).."&Password="..UTIL:url_encode(PASSWORD).."' -L --write-out '%{http_code},%{url_effective}' https://"..API_HOST
		else
			LoginCMD = "rm /tmp/MyQWebLogin_Cookies;curl -b /tmp/MyQWebLogin_Cookies -c /tmp/MyQWebLogin_Cookies  -k -s -o /tmp/MyQWebLogin_Temp https://"..API_HOST.."; curl -b /tmp/MyQWebLogin_Cookies -c /tmp/MyQWebLogin_Cookies  -d 'Email="..UTIL:url_encode(USERNAME).."&Password="..UTIL:url_encode(PASSWORD).."' -L --write-out '%{http_code},%{url_effective}' -k -s -o /tmp/MyQWebLogin_Temp https://"..API_HOST
		end
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::DoLogin): CMD:  ["..LoginCMD.."]")
		local RetVal = UTIL:shellExecute(LoginCMD)
		UTIL:shellExecute("rm -f /tmp/MyQWebLogin_Temp")
		local code,fUrl = RetVal:match("(.*),(.*)")

		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::DoLogin): response:  code ["..(code or "NIL").."] url ["..(fUrl or "NIL").."]")
		if ((code == "200") and (fUrl:find("Dashboard"))) then
			-- login successful - get device list
			-- local dList = getDeviceList()
			PLUGIN_CONFIG.WEB_LOGIN = true
			return true, "Login Success"
		else
			PLUGIN_CONFIG.WEB_LOGIN = false
			return false, "Web Login Failed"
		end
	end
}

MYQ_API = {
	NAME = "MYQ_API",

	getDeviceNameFromID = function(self, DeviceId)
		for k, v in pairs(luup.devices) do
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getDeviceNameFromID: Checking for DEVICE ["..(DeviceId or "NIL").."] testing ["..UTIL:dump(v).."]")
			if (v.id and ((v.id == DeviceId) or (tonumber(v.id) == tonumber(DeviceId)))) then 
				return v.description
			end
		end
		return "UNKNOWN"
	end,

	getUserData = function(self)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getUserData): called.",2)
		local result -- Did we successfully connect, is true or false
		local resultText -- If false, the error, if true, the response
		local ResponseData = {}
		local user_response = {} -- Table to hold our response from the call

		local response, status, header
		local URL = PLUGIN_CONFIG.USER_DATA_URL
		local HEADERS = {
			["Host"] = PLUGIN_CONFIG.BASE_URL:gsub("https://",""):gsub("/",""),
			["Accept"] = "*/*",
			["SecurityToken"] = PLUGIN_CONFIG.SecurityToken,
			["MyQApplicationId"] = PLUGIN_CONFIG.APPID,
			["Culture"] = "en",
			["ApiVersion"] = PLUGIN_CONFIG.MYQ_API_VERSION,
			["App-Version"] = PLUGIN_CONFIG.MYQ_APP_VERSION
		}
		response, status, header = https.request{
			url = URL,
			method = "GET",
			headers = HEADERS,
			verify = "none",
			mode = "client",
			protocol = "tlsv1_2",
			options = "all",
			redirect = false,
			sink = ltn12.sink.table(user_response)
		}
		debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getUserData): GET request  ["..URL.."] Headers ["..UTIL:dump(HEADERS).."].",2)
		-- Check out the response
		if (response == 1) then
			-- Decode our JSON, we have a response
			ResponseData = json:decode(user_response[1])
			-- Check our return code
			if (ResponseData.ReturnCode == "0") then
				result = true
				-- erase personally identifiable info
				ResponseData.FirstName = "******"
				ResponseData.LastName = "******"
				ResponseData.StreetName = "******"
				ResponseData.Street2Name = "******"
				ResponseData.CityName = "******"
				ResponseData.StreetPostalCode = "******"
				ResponseData.MailingListOptIn = nil
				ResponseData.RequestAccountLinkInfo = nil
				resultText = ResponseData
			else
				result = false
				resultText = "Authentication Error!"
				debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getUserData): response ["..UTIL:dump(user_response[1]).."]",2)
				debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getUserData): Authentication error.",1)
			end
		else
			result = false
			resultText = "Unsuccessful at connecting with the check statuses URL!"
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getUserData): Unsuccessful at connecting with the User Data URL!",1)
		end

		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getUserData):    finished - UserData ["..UTIL:dump(resultText).."]",(result and 2 or 1))
		return result, resultText
	end,

	-------------------------------------------------------------------------------------------------------------
	-- --
	-- Connects to the LiftMaster/Chamberlain MyQ API                                                          --
	-- Returns result and resultText, result is boolean, true if  is successful, false otherwise --
	-- resultText holds the reason why a failure occured OR the Security Token                                 --
	-- --
	-------------------------------------------------------------------------------------------------------------
	retrieveSecurityToken = function(self)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): called")
		if (PLUGIN_CONFIG.WEB_LOGIN) then
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): Using WEB_LOGIN. Security token not required.",1)
			return true, "0123456789"
		end
		if (PLUGIN_CONFIG.API_MODE_DISABLED == true) then
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): API LOGIN disabled.",1)
			return false, "API Login Disabled"
		end
		local result -- Did we successfully connect and get the SecurityToken, is true or false
		local resultText -- If false, the error, if true, the SecurityToken
		local authResponseData

		-- Table to hold our response from the call
    local auth_response = {}
		local reqJSON = string.format('{"username":"%s","password":"%s"}',PLUGIN_CONFIG.USERNAME, PLUGIN_CONFIG.PASSWORD)
		local HEADERS = {
			["Host"] = PLUGIN_CONFIG.BASE_URL:gsub("https://",""):gsub("/",""),
			["Accept"] = "*/*",
			["MyQApplicationId"] = PLUGIN_CONFIG.APPID,
			["Culture"] = "en",
			["ApiVersion"] = PLUGIN_CONFIG.MYQ_API_VERSION,
			["App-Version"] = PLUGIN_CONFIG.MYQ_APP_VERSION,
			["Content-Type"] = "application/json; charset=utf-8",
			["Content-Length"] = #reqJSON
		}
		debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): POST request URL: ["..(PLUGIN_CONFIG.VALIDATION_URL or "NIL").."] Headers ["..UTIL:dump(HEADERS).."] Data ["..(reqJSON or "NIL").."]",2)
		local response, status, header = https.request{
			url = PLUGIN_CONFIG.VALIDATION_URL,
			source = ltn12.source.string(reqJSON),
			method = "POST",
			headers = HEADERS,
			verify = "none",
			mode = "client",
			protocol = "tlsv1_2",
			options = "all",
			redirect = false,
			sink = ltn12.sink.table(auth_response)
		}

		-- Check out the response
		debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): received response: "..(auth_response[1] or "NIL"),2)
		if (response == 1) then
				-- Decode our JSON, we have a response
				authResponseData = json:decode(auth_response[1])

				-- Check our return code
				if (authResponseData.ReturnCode == "0") then
					result = true
					resultText = authResponseData.SecurityToken
					PLUGIN_CONFIG.SecurityToken = authResponseData.SecurityToken
					debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): Retrieved security token!",2)
					local ud, userData = self:getUserData()
				else
					result = false
					resultText = "Authentication Error!"
					log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): Authentication error!",1)
				end
		else
			result = false
			resultText = "Unsuccessful at connecting with the authorization URL!"
			log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::retrieveSecurityToken): Unsuccessful at connecting with the authorization URL!",1)
		end

		-- Record our update
		if (result == true) then
			-- Update the UI to show the last date of token refresh
			Timestamp = UTIL:getTimestamp()
			luup.variable_set(MYQGATEWAY_SID, "Timestamp", Timestamp, MyQGatewayID)
		end
		return result, resultText
	end,

	--------------------------------------------------------------------
	-- Retrieves the status of a given device
	--------------------------------------------------------------------
	getStatus = function(self, DeviceId, Attribute)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus): called - DeviceId ["..(DeviceId or "NIL").."] Attribute ["..(Attribute or "NIL").."]",2)
		local result -- Did we successfully connect, is true or false
		local resultText -- If false, the error, if true, the response
		local authResponseData = {}
		local auth_response = {} -- Table to hold our response from the call

		-- Our status URL
		local response, status, header
		if (PLUGIN_CONFIG.WEB_MODE == false) then
			local URL = PLUGIN_CONFIG.GET_DEVICE_ATTR_URL:format(UTIL:url_encode(DeviceId), UTIL:url_encode(Attribute))
			local HEADERS = {
				["Host"] = PLUGIN_CONFIG.BASE_URL:gsub("https://",""):gsub("/",""),
				["Accept"] = "*/*",
				["SecurityToken"] = PLUGIN_CONFIG.SecurityToken,
				["MyQApplicationId"] = PLUGIN_CONFIG.APPID,
				["Culture"] = "en",
				["ApiVersion"] = PLUGIN_CONFIG.MYQ_API_VERSION,
				["App-Version"] = PLUGIN_CONFIG.MYQ_APP_VERSION
			}
			response, status, header = https.request{
				url = URL,
				method = "GET",
				headers = HEADERS,
				verify = "none",
				mode = "client",
				protocol = "tlsv1_2",
				options = "all",
				redirect = false,
				sink = ltn12.sink.table(auth_response)
			}
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus): GET request  ["..URL.."] Headers ["..UTIL:dump(HEADERS).."].",2)
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus): response ["..UTIL:dump(auth_response[1]).."]",2)
			-- Check out the response
			if (response == 1) then
				-- Decode our JSON, we have a response
				authResponseData = json:decode(auth_response[1])
				-- Check our return code
				if (authResponseData.ReturnCode == "0") then
					result = true
					resultText = authResponseData.AttributeValue
					-- handle a response code of 33, which is a session needs to be renewed..
				elseif (output.ReturnCode == "309") then
					-- device (hub/gateway/opener) is offline
					result = false
					resultText = "Communications error. Gateway or Device is offline."
					debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus): Communications error. Device offline.",1)
					local msg = "Communication error. myQ device ["..self:getDeviceNameFromID(DeviceId).."] is offiline."
					task(msg, TASK_ERROR)
				else
					result = false
					resultText = "Authentication Error!"
					debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus): Authentication error.",1)
				end
			else
				result = false
				resultText = "Unsuccessful at connecting with the check statuses URL!"
				debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus): Unsuccessful at connecting with the check status URL!",1)
			end
		else
			response,status = WEB_API:LoadSingleDevice(DeviceId)
			if (response == 1) then
				authResponseData = (json:decode(status))[1]
				debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus): deviceContent: ["..UTIL:dump(authResponseData).."].",2)
				if (Attribute == "online") then
					result = true
					resultText = "True"
				elseif ((Attribute == "doorstate") and (authResponseData.ToggleAttributeName == "desireddoorstate")) then
					result = true
					resultText = authResponseData.State
				elseif ((Attribute == "lightstate") and (authResponseData.ToggleAttributeName == "desiredlightstate")) then
					result = true
					resultText = authResponseData.State
				end
			end
		end

		debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::getStatus):    finished - DeviceId ["..(DeviceId or "NIL").."] Attribute ["..(Attribute or "NIL").."] value ["..(resultText or "NIL").."]",(result and 2 or 1))
		return result, resultText
	end,


	--------------------------------------------------------------------
	--
	-- Change the status of a given device, right now it only changes
	-- the "doorstate" which is either open or closed--
	--
	--------------------------------------------------------------------
	changeDeviceStatus = function(self, DeviceId, UNUSED, AttributeName, AttributeValue)
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::changeDeviceStatus): called")
		-- local authResult, authText = retrieveSecurityToken()
		-- if (authResult == true) then
		-- 	SecurityToken = authText
		-- 	Timestamp = UTIL:getTimestamp()
		-- 	luup.variable_set(MYQGATEWAY_SID, "Timestamp", Timestamp, MyQGatewayID)
		-- 	clearTask()
		-- else
		-- 	local msg = "myQ authorization failed.  Check settings in myQ setup."
		-- 	task(msg, TASK_ERROR_PERM)
		-- 	log("(MyQGateway::changeDeviceStatus): Authorization failed." .. (authText or "No Text"),1)
		-- 	return
		-- end

		local result -- Result of the action, true or false
		local resultText -- Summary of the result

    -- Our JSON to be delivered...
		local jsonPut = {
				MyQDeviceId = DeviceId,
				AttributeName = AttributeName,
				AttributeValue = AttributeValue
		}

    -- JSON encode it for delivery
		local json_data = json:encode(jsonPut)
		local response_body = {}

		local response, status, header
		if (PLUGIN_CONFIG.WEB_MODE == false) then
			-- Fire up our request, noting that we are using the PUT method and setting our content length in the header
			local URL = PLUGIN_CONFIG.SET_DEVICE_ATTR_URL
			local cHEADERS = {
				["Host"] = PLUGIN_CONFIG.BASE_URL:gsub("https://",""):gsub("/",""),
				["Accept"] = "*/*",
				["SecurityToken"] = PLUGIN_CONFIG.SecurityToken,
				["MyQApplicationId"] = PLUGIN_CONFIG.APPID,
				["Culture"] = "en",
				["ApiVersion"] = PLUGIN_CONFIG.MYQ_API_VERSION,
				["App-Version"] = PLUGIN_CONFIG.MYQ_APP_VERSION,
				["Content-Type"] = "application/json",
				["Content-Length"] = string.len(json_data)
			},
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::changeDeviceStatus): PUT request URL ["..(URL or "NIL").."] Headers ["..UTIL:dump(cHEADERS).."] JSON ["..(json_data or "NIL").."].",2)
			response, status, header = https.request{
				method = "PUT",
				url = URL,
				headers = cHEADERS,
				verify = "none",
				mode = "client",
				protocol = "tlsv1_2",
				options = "all",
				redirect = false,
				source = ltn12.source.string(json_data),
				sink = ltn12.sink.table(response_body)
			}
		else
			response, status, header = WEB_API:TriggerStateChange(DeviceId, AttributeName, AttributeValue)
			if (response == 1) then
				response_body[1] = '{"ReturnCode":"0"}'
			end
		end
		debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::changeDeviceStatus): received response: "..(response_body[1] or "NIL"),2)
		if (response == 1) then
				local output = json:decode(response_body[1])
				if (output.ReturnCode == "0") then
						result = true
						resultText = "Successfully changed status to " .. tostring(AttributeValue)
						local refreshAfterChangeInterval = luup.variable_get(MYQGATEWAY_SID, "RefreshAfterChangeInterval", MyQGatewayID)

						if (PLUGIN_CONFIG.UI7_GDO and PLUGIN_CONFIG.ENHANCED_STATUS) then
								luup.call_delay('justRefreshDevices', 5, "")
						elseif (refreshAfterChangeInterval ~= nil and tonumber(refreshAfterChangeInterval) > 0) then
								debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::changeDeviceStatus): refresh door status after " .. refreshAfterChangeInterval)
								luup.call_delay('justRefreshDevices', tonumber(refreshAfterChangeInterval), "") -- Check the status of the doors, currently every 90 seconds
						end

				elseif (output.ReturnCode == "309") then
					-- device (hub/gateway/opener) is offline
					result = false
					resultText = "Communications error. Gateway or Device is offline."
					debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::changeDeviceStatus): Communications error. Device offline.",1)
					local msg = "Communication error. myQ device ["..self:getDeviceNameFromID(DeviceId).."] is offiline."
					task(msg, TASK_ERROR)

				else
						result = false
						resultText = "Authentication error. Perhaps token expired?"
						debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::changeDeviceStatus): Authentication error.",1)
				end
		else
				result = false
				resultText = "Unsuccessful at communicating with the setDeviceAttribute service"
				debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::changeDeviceStatus): Unsuccessful at communicating with the setDeviceAttribute service.",1)
		end
		return result, resultText
	end,

	--	Inspect all devices associated with the MyQ
	--	NOTE: A Return code of -3333 is a login error and need to login again
	inspectDevices = function(self)

		local function deviceHasAttribute(device, attributeName)
			if (device and device.Attributes) then
				for j, attr in ipairs(device.Attributes) do
					if (attr.AttributeDisplayName and (attr.AttributeDisplayName == attributeName)) then
						return true
					end
				end
			end
			return false
		end

		local function arrayHasValue(array,value)
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices::arrayHasValue): called - testing for value ["..(value or "NIL").."]",2)
			if (array) then
				for k,v in pairs(array) do 
					if v == value then 
						debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices::arrayHasValue): returning TRUE",2)
						return true 
					end
				end
			end
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices::arrayHasValue): returning FALSE",2)
			return false
		end

		-- Statuses for doors
		local doorStatuses = {
		  ["1"] = "open",
		  ["2"] = "closed",
			["3"] = "mid-stop",
		  ["4"] = "opening",
		  ["5"] = "closing",
		  ["7"] = "faulted",
			["9"] = "not closed"
		}

		-- Status values for lights
		local lightStatuses = {
			["0"] = "off",
			["1"] = "on",
			["2"] = "off"
		}

		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): called - SecurityToken ["..UTIL:dump(PLUGIN_CONFIG.SecurityToken).."]")
		local connectionResult -- True if successful, false if not
		local connectionText -- Holds issue with connection
		local openerInfo = {} -- Table to hold info about openers
		local device_response = {} -- Table to hold our response from the call
		local ParentName = nil
		local ParentId = nil
		local numGDO = 0
		local numLights= 0
		local DontAdd = false
		local response, status, header
		local deviceURL = PLUGIN_CONFIG.USER_DEVICE_DETAILS_URL
	
		-- Fire up our connection
		if (PLUGIN_CONFIG.WEB_MODE == false) then
			local HEADERS = {
				["Host"] = PLUGIN_CONFIG.BASE_URL:gsub("https://",""):gsub("/",""),
				["Accept"] = "*/*",
				["SecurityToken"] = PLUGIN_CONFIG.SecurityToken,
				["MyQApplicationId"] = PLUGIN_CONFIG.APPID,
				["Culture"] = "en",
				["ApiVersion"] = PLUGIN_CONFIG.MYQ_API_VERSION,
				["App-Version"] = PLUGIN_CONFIG.MYQ_APP_VERSION,
				["Content-Type"] = "application/json"
			}
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): GET request ["..(deviceURL or "NIL").."] headers ["..UTIL:dump(HEADERS).."].",2)
			response, status, header = https.request{
				url = deviceURL,
				method = "GET",
				headers = HEADERS,
				verify = "none",
				mode = "client",
				protocol = "tlsv1_2",
				options = "all",
				redirect = false,
				sink = ltn12.sink.table(device_response)
			}
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): response ["..UTIL:dump(table.concat(device_response or {}) or "NIL").."]",2)
		else
			response, status, header = WEB_API:getDeviceList()
			device_response = status
		end
		-- Check out our response
		if (response == 1) then
			-- log(device_response)
			-- Decode our JSON: Am unclear as to why device_response[1] threw an error
			-- local deviceContent = json:decode(device_response[1])
			local deviceContent = {}
			if (PLUGIN_CONFIG.WEB_MODE == false) then
				deviceContent = json:decode(table.concat(device_response))
			else
				deviceContent.ReturnCode = "0"
				deviceContent.Devices = json:decode(device_response)
			end

			-- A 0 appears to indicate we have had a success
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): deviceContent: ["..UTIL:dump(deviceContent).."].",(deviceContent.ReturnCode == "0") and 2 or 1)
			if (deviceContent.ReturnCode == "0") then
				debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Parsing deviceContent.",2)
				connectionResult = true
				local numOpeners = 0
				-- Time to loop over our device collection
				for i, dx in ipairs(deviceContent.Devices) do
					local d = dx
					local DeviceName, DeviceId, DEVICE_TYPE
					DEVICE_TYPE = ""

					if (PLUGIN_CONFIG.WEB_MODE == false) then
						DeviceName = d.DeviceName
						DeviceId = d.MyQDeviceId
					else
						DeviceName = d.Name
						DeviceId = d.MyQDeviceId
						d.MyQDeviceTypeId = d.DeviceTypeId
					end
				
					-- GARAGE_DOOR_OPENER array holds the known values of garage door opener type Ids	
					-- LIGHT_SWITCH_DEVICE  the known values for a light switch. (Any device represented by a binary light switch)
					-- GATEWAY_DEVICE holds the known value of the gateway device 

					-- Determine the device type of the current device
					if (arrayHasValue(GATEWAY_DEVICE,tonumber(d.TypeId,10)) or 
							arrayHasValue(PLUGIN_CONFIG.GATEWAY_CSV,tonumber(d.TypeId,10)) or
							arrayHasValue(MyQDeviceTypeIds.GATEWAY,tonumber(d.MyQDeviceTypeId,10)) or
							arrayHasValue(PLUGIN_CONFIG.GATEWAY_CSV,tonumber(d.MyQDeviceTypeId,10)) or
							(d.MyQDeviceTypeName:sub(1,7) == "Gateway")
							) then
						DEVICE_TYPE = "GATEWAY"
						debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Identified GATEWAY device.",2)
					elseif (
							arrayHasValue(LIGHT_SWITCH_DEVICE,tonumber(d.TypeId,10)) or 
							arrayHasValue(PLUGIN_CONFIG.LIGHT_CSV,tonumber(d.TypeId,10)) or 
							arrayHasValue(MyQDeviceTypeIds.LIGHT,tonumber(d.MyQDeviceTypeId,10)) or 
							arrayHasValue(PLUGIN_CONFIG.LIGHT_CSV,tonumber(d.MyQDeviceTypeId,10)) or 
							(d.MyQDeviceTypeName == "LightController") or
							(d.MyQDeviceTypeName == "LampModule")
							) then
						DEVICE_TYPE = "LIGHT_SWITCH"
						debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Identified LIGHT_SWITCH device.",2)
					elseif (
							arrayHasValue(MyQDeviceTypeIds.NEST,tonumber(d.MyQDeviceTypeId,10)) or 
							(d.MyQDeviceTypeName == "Structure")
							) then
						DEVICE_TYPE = "NEST_STRUCTURE"
						debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Identified NEST STRUCTURE device.",2)
					elseif (
							arrayHasValue(MyQDeviceTypeIds.CAMERA,tonumber(d.MyQDeviceTypeId,10)) or 
							(d.MyQDeviceTypeName:sub(1,6) == "Camera")
							) then
						DEVICE_TYPE = "NEST_CAMERA"
						debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Identified NEST CAMERA device.",2)
					elseif (
							arrayHasValue(GARAGE_DOOR_OPENER,tonumber(d.TypeId,10)) or 
							arrayHasValue(PLUGIN_CONFIG.OPENER_CSV,tonumber(d.TypeId,10)) or 
							arrayHasValue(MyQDeviceTypeIds.OPENER,tonumber(d.MyQDeviceTypeId,10)) or 
							arrayHasValue(PLUGIN_CONFIG.OPENER_CSV,tonumber(d.MyQDeviceTypeId,10)) or 
							(d.MyQDeviceTypeName == "GarageDoorOpener") or
							(d.MyQDeviceTypeName:sub(1,18) == "Garage Door Opener")
							) then
						DEVICE_TYPE = "GARAGE_DOOR_OPENER"
						debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Identified GARAGE_DOOR_OPENER device.",2)
					else
						-- specific search did not find the device type - try to deduce it
						if (deviceHasAttribute("doorstate") or (d.ToggleAttributeName == "desireddoorstate")) then
							DEVICE_TYPE = "GARAGE_DOOR_OPENER"
							debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Deduced GARAGE_DOOR_OPENER device.",2)
						elseif (deviceHasAttribute("lightstate") or (d.ToggleAttributeName == "desiredlightstate")) then
							DEVICE_TYPE = "LIGHT_SWITCH"
							debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Deduced LIGHT_SWITCH device.",2)
						end
					end

					-- This is only going to return a single "Place" / gateway. fix at some point to handle multiple gateways.
					if (DEVICE_TYPE == "GATEWAY") then
						ParentName = DeviceId
						for k, attr in ipairs(d.Attributes) do
							if (attr.Name == "desc") then
								ParentId = attr.Value
								--break
							end
						end
					elseif (DEVICE_TYPE == "NEST_STRUCTURE") or (DEVICE_TYPE == "NEST_CAMERA") then 
						DontAdd = true
					elseif (DEVICE_TYPE == "GARAGE_DOOR_OPENER") or (DEVICE_TYPE == "LIGHT_SWITCH") then 
						-- Perhaps MyQDeviceTypeId might be the ticket here, look for 2 in this case
						-- Stop the presses, we found an opener, gate, or light switch
						numOpeners = numOpeners + 1
						local deviceState
						DontAdd = false
						-- Each device has an attributes collection, over it we go
						local deviceStateValue
						if (PLUGIN_CONFIG.WEB_MODE == false) then
							for j, attr in ipairs(d.Attributes) do
								debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): ATTRIBUTES FOR " .. d.MyQDeviceId .. ": " .. attr.AttributeDisplayName .. "=" .. attr.Value)
								if (attr.AttributeDisplayName == "desc") then
									openerName = attr.Value
								elseif (attr.AttributeDisplayName == "doorstate")  then
									deviceStateValue = attr.Value
									if (doorStatuses[deviceStateValue] ~= nil) then
										deviceState = doorStatuses[deviceStateValue]
									else
										deviceState = "ERROR: Unknown Door State! " .. deviceStateValue
									end
								elseif (attr.AttributeDisplayName == "lightstate") then
									deviceStateValue = attr.Value
									if (lightStatuses[deviceStateValue] ~= nil) then
										deviceState = lightStatuses[deviceStateValue]
									else
										deviceState = "ERROR: Unknown Light State! " .. deviceStateValue
									end							
								end
								if (attr.AttributeDisplayName == "numdpsdevices" or attr.AttributeDisplayName == "numookdevices") then
									--Exclude the door opener if the values for both of the above attributes is zero.
									--I believe this happens for MyQ gateway devices that support 2 openers, but only
									--one opener is actually set-up.
									if tostring(attr.Value) == "0" then
										DontAdd = true
									end
								end
							end
						else
							-- massage the web data into usable form
							openerName = d.Name
							d.SerialNumber = "N/A"
							d.RegistrationDateTime = d.Statesince
							if (d.ToggleAttributeName == "desireddoorstate")  then
								deviceStateValue = d.State
								if (doorStatuses[deviceStateValue] ~= nil) then
									deviceState = doorStatuses[deviceStateValue]
								else
									deviceState = "ERROR: Unknown Door State! " .. deviceStateValue
								end
							elseif (d.ToggleAttributeName == "desiredlightstate") then
								deviceStateValue = d.State
								if (lightStatuses[deviceStateValue] ~= nil) then
									deviceState = lightStatuses[deviceStateValue]
								else
									deviceState = "ERROR: Unknown Light State! " .. deviceStateValue
								end							
							end
						end
						if ((d.SerialNumber == "") or (d.RegistrationDateTime == "")) then
							-- no serial number or registration date = no opener attached
							DontAdd = true
						end

						if DontAdd == false then
							-- Keep track of all the openers along with their state
							table.insert(openerInfo, numOpeners, {
								DeviceId = DeviceId,
								DeviceName = DeviceName,
								DeviceState = deviceState, -- used to be DoorState holds the state of either the garage door opener, or the light switch
								DeviceStateValue = deviceStateValue,  -- used to be DoorValue
								OpenerName = openerName,
								DeviceType = DEVICE_TYPE
							})
							if DEVICE_TYPE == "GARAGE_DOOR_OPENER" then
								numGDO=numGDO+1
								debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Added GARAGE_DOOR_OPENER device.",2)
							else	
								numLights=numLights+1
								debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Added LIGHT_SWITCH device.",2)
							end
						else
							numOpeners=numOpeners-1
						end
					else
						-- we encountered an unknown device type.  Log it so that it could be included in subsequent releases.
						-- It's likely either going to be a gate opener or some kind of switch
						log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Unknown Device Type Encountered.  Device Type ID: " .. (d.TypeId or d.MyQDeviceTypeId or "NIL"),1)
						log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Dump of UNKNOWN DEVICE attributes: " .. UTIL:dump(d),1)
						log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Try adding the devices Type ID to the plugins Gateway_CSV, Opener_CSV or Light_CSV variable!",1)
					end
				end
			else
				-- deviceContent.ReturnCode ~=0
				connectionResult = false
				connectionText = "Failed call to the MyQ API, perhaps refresh of token needed?"
				debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Failed call to the MyQ API, perhaps refresh of token needed?",1)
			end
		else
			-- https response ~=1
			connectionResult = false
			connectionText = "Unsuccessful at connecting with device URL!"
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Unsuccessful at connecting with device URL!",1)
		end
	
		if connectionResult == true then
			luup.variable_set(MYQGATEWAY_SID, "numDoors", tostring(numGDO), MyQGatewayID)
			luup.variable_set(MYQGATEWAY_SID, "numLights", tostring(numLights), MyQGatewayID)
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): Retrieved device data",2)
		else
			luup.variable_set(MYQGATEWAY_SID, "numDoors", "ERROR: Could not initialize connection.", MyQGatewayID)
			luup.variable_set(MYQGATEWAY_SID, "numLights", "        Check brand, username and password.", MyQGatewayID)	
			debug("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::inspectDevices): FAILED to Retreived device data",1)
		end
		return connectionResult, openerInfo, ParentId, ParentName
	end
}



UPnP = {
	NAME = "UPnP",
	DoorLock1_SetTarget = function(self, lul_device, lul_settings)
		local openerID = lul_device
		local targetValue = lul_settings.newTargetValue
		--I have the device id, not sure if there's an easier way to lookup the properties luup.devices[deviceId].id doesn't seem to work
		local myQid = child_deviceid_lookup_table[lul_device]
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::DoorLock1_SetTarget): device [" .. (lul_device or "NIL").. "] Target [" .. (lul_settings.newTargetValue or "NIL").. "] myQid [" .. (myQid or "NIL").. "].")

		--Lock/Close the garage door
		if (targetValue == "1") then
			local deviceStatResult, deviceStatText = MYQ_API:changeDeviceStatus(myQid, APPID, "desireddoorstate", 0, SecurityToken)
			if (deviceStatResult == true) then
				luup.variable_set("urn:micasaverde-com:serviceId:DoorLock1", "Status", 1, openerID)
			end

			--Unlock/Open the given garage door
		elseif (targetValue == "0") then
			local deviceStatResult, deviceStatText = MYQ_API:changeDeviceStatus(myQid, APPID, "desireddoorstate", 1, SecurityToken)
			if (deviceStatResult == true) then
				luup.variable_set("urn:micasaverde-com:serviceId:DoorLock1", "Status", 0, openerID)
			end
		end
		return 4, nil
	end,

	SwitchPower1_SetTarget = function(self, lul_device, lul_settings)
		local targetValue = lul_settings.newTargetValue
		local myQid = child_deviceid_lookup_table[lul_device]
		local switchID = lul_device
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::SwitchPower1_SetTarget): device [" .. (lul_device or "NIL").. "] Target [" .. (lul_settings.newTargetValue or "NIL").. "] myQid [" .. (myQid or "NIL").. "].")
			
		if tostring(targetValue) == "1" then
			-- Turn on the light
			local deviceStatResult, deviceStatText = MYQ_API:changeDeviceStatus(myQid, APPID, "desiredlightstate", 1, SecurityToken)
			if (deviceStatResult == true) then
				luup.variable_set("urn:upnp-org:serviceId:SwitchPower1", "Status", 1, switchID)
			end				
		else
			-- turn off the light
			local deviceStatResult, deviceStatText = MYQ_API:changeDeviceStatus(myQid, APPID, "desiredlightstate", 0, SecurityToken)
			if (deviceStatResult == true) then
				luup.variable_set("urn:upnp-org:serviceId:SwitchPower1", "Status", 0, switchID)
			end					
		end
		return 4, nil
	end,

	MyQGateway1_SetBrand = function(self, lul_device, lul_settings)
		luup.log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::SetBrand): lul_settings ["..UTIL:dump(lul_settings).."]")
		local brand = lul_settings.newBrand
		luup.variable_set("urn:macrho-com:serviceId:MyQGateway1","Brand",brand,lul_device)
		task("Please wait....Re-initializing myQ.", TASK_ERROR_PERM)
		init()
		return 4, nil
	end,
	
	MyQGateway1_SetUsernamePassword = function(self, lul_device, lul_settings)
		luup.log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::SetUsernamePassword): lul_settings ["..UTIL:dump(lul_settings).."]")
		local Username = lul_settings.newUsername or ""
		local Password = lul_settings.newPassword or ""
		if Username ~= "" then
			luup.variable_set("urn:macrho-com:serviceId:MyQGateway1","Username",Username,lul_device)
		end
		if Password ~= "" then
			luup.variable_set("urn:macrho-com:serviceId:MyQGateway1","Password",Password,lul_device)		 
		end 
		task("Please wait....Re-initializing myQ.", TASK_ERROR_PERM)
		init()
		return 4, nil
	end,

	ToggleDebugMode = function(self, lul_device)
		if (PLUGIN_CONFIG.DEBUG_MODE == true) then
			PLUGIN_CONFIG.DEBUG_MODE = false
			luup.variable_set(MYQGATEWAY_SID, "DEBUG_MODE", "0", lul_device)
			luup.variable_set(MYQGATEWAY_SID, "DEBUG_MODE_TEXT", "DISABLED", lul_device)
			task("DEBUG MODE DISABLED!",TASK_SUCCESS)
		else
			PLUGIN_CONFIG.DEBUG_MODE = true
			luup.variable_set(MYQGATEWAY_SID, "DEBUG_MODE", "1", lul_device)
			luup.variable_set(MYQGATEWAY_SID, "DEBUG_MODE_TEXT", "ENABLED", lul_device)
			task("DEBUG MODE ENABLED!",TASK_SUCCESS)
		end
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::ToggleDebugMode): Debug mode now ["..(PLUGIN_CONFIG.DEBUG_MODE and "ENABLED" or "DISABLED").."].")
	end,

	ToggleGDOMode = function(self, lul_device)
		if (PLUGIN_CONFIG.UI7_GDO == true) then
			PLUGIN_CONFIG.UI7_GDO = false
			luup.variable_set(MYQGATEWAY_SID, "UI7_GDO", "0", lul_device)
			luup.variable_set(MYQGATEWAY_SID, "UI7_GDO_TEXT", "DISABLED", lul_device)
			task("UI7_GDO MODE DISABLED!",TASK_SUCCESS)
		else
			PLUGIN_CONFIG.UI7_GDO = true
			luup.variable_set(MYQGATEWAY_SID, "UI7_GDO", "1", lul_device)
			luup.variable_set(MYQGATEWAY_SID, "UI7_GDO_TEXT", "ENABLED", lul_device)
			task("UI7_GDO MODE ENABLED!",TASK_SUCCESS)
		end
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::ToggleGDOMode): UI7 GDO mode now ["..(PLUGIN_CONFIG.UI7_GDO and "ENABLED" or "DISABLED").."].")
	end,

	ToggleEnhStatus = function(self, lul_device)
		if (PLUGIN_CONFIG.ENHANCED_STATUS == true) then
			PLUGIN_CONFIG.ENHANCED_STATUS = false
			luup.variable_set(MYQGATEWAY_SID, "ENH_STATUS", "0", lul_device)
			luup.variable_set(MYQGATEWAY_SID, "ENH_STATUS_TEXT", "DISABLED", lul_device)
			task("Enhanced Status DISABLED!",TASK_SUCCESS)
		else
			PLUGIN_CONFIG.ENHANCED_STATUS = true
			luup.variable_set(MYQGATEWAY_SID, "ENH_STATUS", "1", lul_device)
			luup.variable_set(MYQGATEWAY_SID, "ENH_STATUS_TEXT", "ENABLED", lul_device)
			task("Enhanced Status ENABLED!",TASK_SUCCESS)
		end
		log("("..PLUGIN_CONFIG.NAME.."::"..self.NAME.."::ToggleEnhStatus): UI7 GDO mode now ["..(PLUGIN_CONFIG.ENHANCED_STATUS and "ENABLED" or "DISABLED").."].")
	end

}

------------------------------------
--
-- This is our start up code
--
------------------------------------
function init(lul_device)
	if (MyQGatewayID == nil) then MyQGatewayID = lul_device end -- save the global device ID
	local isDisabled = luup.attr_get("disabled", lul_device)
	if ((isDisabled == 1) or (isDisabled == "1")) then
		log("(MyQGateway::init): MyQ Gateway Plugin "..version.." - ************** DISABLED **************",1)
		PLUGIN_CONFIG.PLUGIN_DISABLED = true
		-- mark device as disabled
		return true, "Plugin Disabled.", "MyQGateway"
	end
	log("(MyQGateway::init): MyQ Gateway Plugin "..version.." - ************** STARTING **************",2)
	-- Not sure why, but the task (status) seems to only work as expected when the function is called via timer.
	-- This allows a status message to appear for the device to allow the user to change settings, while at the same time
	-- does not "fail" the initiation.  this allows the user to make use of the UI to set the initial parameters
	-- instead of going to advanced tab and manually enter values which could be problematic for some.
	
	luup.variable_set (MYQGATEWAY_SID,"PLUGIN_VERSION",version,MyQGatewayID)

	UTIL:setVariableDefault(MYQGATEWAY_SID, "Username", "", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "Password", "", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "Brand", "", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "RefreshInterval", 120, MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "RefreshAfterChangeInterval", 30, MyQGatewayID)

	UTIL:setVariableDefault(MYQGATEWAY_SID, "DEBUG_MODE", "0", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "DEBUG_MODE_TEXT", "DISABLED", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "UI7_GDO", "0", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "UI7_GDO_TEXT", "DISABLED", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "ENH_STATUS", "0", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "ENH_STATUS_TEXT", "DISABLED", MyQGatewayID)

	UTIL:setVariableDefault(MYQGATEWAY_SID, "Gateway_CSV", "", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "Opener_CSV", "", MyQGatewayID)
	UTIL:setVariableDefault(MYQGATEWAY_SID, "Light_CSV", "", MyQGatewayID)

	if (UTIL:IsUI7()) then
		luup.set_failure(0)
	else
		luup.set_failure(false)
	end
	if (DEVICE_ICONS) then
		DEVICE_ICONS:createIcons(UTIL:IsUI7())
		DEVICE_ICONS = nil
	end

	PLUGIN_CONFIG.BRAND = luup.variable_get(MYQGATEWAY_SID, "Brand", MyQGatewayID)

	-- load the PLUGIN_CONFIG variables before the deferred startup code runs
	PLUGIN_CONFIG.DEBUG_MODE = (tonumber(luup.variable_get(MYQGATEWAY_SID, "DEBUG_MODE", MyQGatewayID),10) == 1) and true or (PLUGIN_CONFIG.FORCE_DEBUG or false)
	PLUGIN_CONFIG.UI7_GDO = (tonumber(luup.variable_get(MYQGATEWAY_SID, "UI7_GDO", MyQGatewayID),10) == 1) and true or false
	PLUGIN_CONFIG.ENHANCED_STATUS = (tonumber(luup.variable_get(MYQGATEWAY_SID, "ENH_STATUS", MyQGatewayID),10) == 1) and true or false
	log("(MyQGateway::init): MyQ Gateway Plugin Options - BRAND ["..(PLUGIN_CONFIG.BRAND or "NOT SET").."] DEBUG_MODE ["..(PLUGIN_CONFIG.DEBUG_MODE and "ENABLED" or "DISABLED").."] UI7_GDO ["..(PLUGIN_CONFIG.UI7_GDO and "ENABLED" or "DISABLED").."]",2)
	luup.variable_set(MYQGATEWAY_SID, "DEBUG_MODE_TEXT", (PLUGIN_CONFIG.DEBUG_MODE and "ENABLED" or "DISABLED"), lul_device)
	luup.variable_set(MYQGATEWAY_SID, "UI7_GDO_TEXT", (PLUGIN_CONFIG.UI7_GDO and "ENABLED" or "DISABLED"), lul_device)
	luup.variable_set(MYQGATEWAY_SID, "ENH_STATUS_TEXT", (PLUGIN_CONFIG.ENHANCED_STATUS and "ENABLED" or "DISABLED"), lul_device)

	local GATEWAY_CSV = loadstring("return {"..luup.variable_get(MYQGATEWAY_SID, "Gateway_CSV", MyQGatewayID).."}")
	if pcall(GATEWAY_CSV) then PLUGIN_CONFIG.GATEWAY_CSV = GATEWAY_CSV() else 
		PLUGIN_CONFIG.GATEWAY_CSV = {}
		luup.log ("MyQGateway::Init): ERROR - Gateway_CSV variable does not contain a valid comma seperated list",1)
	end
	log ("MyQGateway::Init): Gateway_CSV ["..UTIL:dump(PLUGIN_CONFIG.GATEWAY_CSV).."]")

	local OPENER_CSV = loadstring("return {"..luup.variable_get(MYQGATEWAY_SID, "Opener_CSV", MyQGatewayID).."}")
	if pcall(OPENER_CSV) then PLUGIN_CONFIG.OPENER_CSV = OPENER_CSV() else 
		PLUGIN_CONFIG.OPENER_CSV = {}
		luup.log ("MyQGateway::Init): ERROR - Opener_CSV variable does not contain a valid comma seperated list",1)
	end
	log ("MyQGateway::Init): Opener_CSV ["..UTIL:dump(PLUGIN_CONFIG.OPENER_CSV).."]")

	local LIGHT_CSV = loadstring("return {"..luup.variable_get(MYQGATEWAY_SID, "Light_CSV", MyQGatewayID).."}")
	if pcall(LIGHT_CSV) then PLUGIN_CONFIG.LIGHT_CSV = LIGHT_CSV() else
		PLUGIN_CONFIG.LIGHT_CSV = {}
		luup.log ("MyQGateway::Init): ERROR - light_CSV variable does not contain a valid comma seperated list",1)
	end
	log ("MyQGateway::Init): Light_CSV ["..UTIL:dump(PLUGIN_CONFIG.LIGHT_CSV).."]")

	luup.call_timer("startupDeferred", 1, "1", "")
	return true, "Plugin starting.", "MyQGateway"
end

function startupDeferred()

	local foundIssue = false --Any problem with username/password/brand?
	local issueMessage = "ERROR: " --Our fancy error message


	-- Grab our username and password from advanced
	-- Throw an error if any or both are not set below
	PLUGIN_CONFIG.USERNAME = luup.variable_get(MYQGATEWAY_SID, "Username", MyQGatewayID)
	if (PLUGIN_CONFIG.USERNAME == nil or PLUGIN_CONFIG.USERNAME == "") then
		luup.variable_set(MYQGATEWAY_SID, "Username", "", MyQGatewayID)
		foundIssue = true
		issueMessage = "Username not configured. "
		debug("(MyQGateway::startupDeferred): MyQ Username not specified.",1)
		--return false, "Please configure your MyQ Username", "MyQGateway"
	end

	PLUGIN_CONFIG.PASSWORD = luup.variable_get(MYQGATEWAY_SID, "Password", MyQGatewayID)
	if (PLUGIN_CONFIG.PASSWORD == nil or PLUGIN_CONFIG.PASSWORD == "") then
		luup.variable_set(MYQGATEWAY_SID, "Password", "", MyQGatewayID)
		foundIssue = true
		issueMessage = issueMessage .. "Password not configured."
		debug("(MyQGateway::startupDeferred): MyQ Password not specified.",1)
		--return false, "Please configure your MyQ Password", "MyQGateway"
	end

	PLUGIN_CONFIG.BRAND = luup.variable_get(MYQGATEWAY_SID, "Brand", MyQGatewayID)
	if (PLUGIN_CONFIG.BRAND == nil or PLUGIN_CONFIG.BRAND == "") then
		luup.variable_set(MYQGATEWAY_SID, "Brand", "", MyQGatewayID)
		foundIssue = true
		issueMessage = "Opener brand not configured. "
		debug("(MyQGateway::startupDeferred): MyQ Brand not specified.",1)
		--return false, "Please configure your opener brand (Liftmaster/Chamberlain/Craftsman)", "MyQGateway"
	end

	local refreshInterval = luup.variable_get(MYQGATEWAY_SID, "RefreshInterval", MyQGatewayID)
	if (refreshInterval ~= nil and tonumber(refreshInterval) > 0) then
		log('(MyQGateway::startupDeferred): Status refresh on your opener(s) will be called every:' .. refreshInterval)
	else
		log('(MyQGateway::startupDeferred): Setting refresh interval to 120 sec by default')
		luup.variable_set(MYQGATEWAY_SID, "RefreshInterval", 120, MyQGatewayID)
	end

	local refreshAfterChangeInterval = luup.variable_get(MYQGATEWAY_SID, "RefreshAfterChangeInterval", MyQGatewayID)
	if (refreshAfterChangeInterval == nil) then
		--   log('Setting refresh after change interval to:' .. refreshAfterChangeInterval)
		luup.variable_set(MYQGATEWAY_SID, "RefreshAfterChangeInterval", 30, MyQGatewayID)
	end

	--Throw up an error if username and/or password are not configured
	if (foundIssue == true) then
		local msg = issueMessage .. "  Check settings in myQ setup."
		task(msg, TASK_ERROR_PERM)
		luup.variable_set (MYQGATEWAY_SID,"numDoors",issueMessage,MyQGatewayID)
		luup.variable_set (MYQGATEWAY_SID,"numLights","",MyQGatewayID)
		log("(MyQGateway::startupDeferred): MyQ Gateway Plugin "..version.." - ********** STARTUP COMPLETE **********",1)
		return
	end


	log("(MyQGateway::startupDeferred): Configuring for brand ["..(PLUGIN_CONFIG.BRAND or "NIL").."].")
	PLUGIN_CONFIG.APPID = BRANDING[PLUGIN_CONFIG.BRAND].APPID
	PLUGIN_CONFIG.BASE_URL = BRANDING[PLUGIN_CONFIG.BRAND].BASE_URL

	if ((PLUGIN_CONFIG.BRAND ~= "Craftsman") and (PLUGIN_CONFIG.BRAND ~= "Liftmaster") and (PLUGIN_CONFIG.BRAND ~= "Chamberlain")) then
		log("(MyQGateway::startupDeferred): Unknown brand ["..(PLUGIN_CONFIG.BRAND or "NIL").."] - defaulting to Chamberlain",1)
		PLUGIN_CONFIG.APPID = BRANDING["Chamberlain"].APPID
		PLUGIN_CONFIG.BASE_URL = BRANDING["Chamberlain"].BASE_URL
	end

	PLUGIN_CONFIG.VALIDATION_URL = PLUGIN_CONFIG.BASE_URL .. "api/v4/User/Validate"
--	GET_DEVICE_ATTR_URL = BASE_URL .. "/api/v4/DeviceAttribute/GetDeviceAttribute?SecurityToken=%s&MyQDeviceId=%s&attributeName=%s"
--	SET_DEVICE_ATTR_URL = BASE_URL .. "/api/v4/DeviceAttribute/PutDeviceAttribute?SecurityToken=%s"
--	USER_DEVICE_DETAILS_URL = BASE_URL .. "api/v4/UserDeviceDetails/Get?SecurityToken=%s"
--	USER_DATA_URL = BASE_URL .. "api/v4/User/GetUser?SecurityToken=%s"
	PLUGIN_CONFIG.GET_DEVICE_ATTR_URL = PLUGIN_CONFIG.BASE_URL .. "/api/v4/DeviceAttribute/GetDeviceAttribute?MyQDeviceId=%s&attributeName=%s"
	PLUGIN_CONFIG.SET_DEVICE_ATTR_URL = PLUGIN_CONFIG.BASE_URL .. "/api/v4/DeviceAttribute/PutDeviceAttribute"
	PLUGIN_CONFIG.USER_DEVICE_DETAILS_URL = PLUGIN_CONFIG.BASE_URL .. "api/v4/UserDeviceDetails/Get"
	PLUGIN_CONFIG.USER_DATA_URL = PLUGIN_CONFIG.BASE_URL .. "api/v4/User/GetUser"

	log("(MyQGateway::startupdeferred): ATTEMPTING INITIAL API LOGIN")
	PLUGIN_CONFIG.WEB_MODE = false
	-- Get our security token, making sure we encode our username and password
	local authResult, authText = MYQ_API:retrieveSecurityToken()
	-- Is everything ok here?
	if (authResult == true) then
		log("(MyQGateway::startupdeferred): INITIAL API LOGIN SUCCESSFUL!!")
		log("(MyQGateway::startupdeferred): Our initial security token is " .. PLUGIN_CONFIG.SecurityToken)
	else
		log("(MyQGateway::startupdeferred): INITIAL API LOGIN **FAILED**  Attempting WEB MODE fallback",1)
		if (PLUGIN_CONFIG.WEB_MODE == false) then
			-- try to use the web login as fallback
			authResult, authText = WEB_API:DoLogin()
			if (authResult == true) then
				-- web login successful
				log("(MyQGateway::startupdeferred): INITIAL WEB MODE LOGIN SUCCEEDED!!!")
				PLUGIN_CONFIG.WEB_MODE = true
			else
				log("(MyQGateway::startupdeferred): INITIAL WEB MODE LOGIN *** FAILED ***",1)
			end
		end
	end
	if (authResult == false) then
		local msg = "myQ authorization failed.  Check settings in myQ setup."
		task(msg, TASK_ERROR_PERM)
		log("(MyQGateway::startupdeferred): Authorization failed." .. (authText or "No Text"))
		luup.variable_set (MYQGATEWAY_SID,"numDoors","myQ authorization failed.",MyQGatewayID)
		luup.variable_set (MYQGATEWAY_SID,"numLights","Check brand, user name and password.",MyQGatewayID)
		log("(MyQGateway::startupDeferred): Unable to continue. Exiting.",1)
		log("(MyQGateway::startupDeferred): MyQ Gateway Plugin "..version.." - ********** STARTUP COMPLETE **********",1)
		return
	end

	Timestamp = UTIL:getTimestamp()
	luup.variable_set(MYQGATEWAY_SID, "Timestamp", Timestamp, MyQGatewayID)
	clearTask()

	------------------------------------------------------
	-- --
	-- Check out the devices we have and build children --
	-- --
	------------------------------------------------------

	local connectionResult, openerInfo, ParentName, ParentId = MYQ_API:inspectDevices()
	if ((connectionResult == false) and (PLUGIN_CONFIG.WEB_MODE == false)) then
		-- API authentication succeeded but retrieving device list failed - force web mode fallback
		log("(MyQGateway::startupdeferred): INITIAL inspectDevices **FAILED**  Attempting WEB MODE fallback")
		authResult, authText = WEB_API:DoLogin()
		if (authResult == true) then
			-- web login successful
			log("(MyQGateway::startupdeferred): FALLBACK WEB MODE LOGIN SUCCEEDED!!!")
			PLUGIN_CONFIG.WEB_MODE = true
			connectionResult, openerInfo, ParentName, ParentId = MYQ_API:inspectDevices()
		else
			log("(MyQGateway::startupdeferred): FALLBACK WEB MODE LOGIN *** FAILED ***",1)
			log("(MyQGateway::startupDeferred): Unable to continue. Exiting.",1)
			log("(MyQGateway::startupDeferred): MyQ Gateway Plugin "..version.." - ********** STARTUP COMPLETE **********",1)
			return
		end
	end

	if (connectionResult) then
		-- Our currently configured openers
		local currentOpeners = luup.variable_get(MYQGATEWAY_SID, "OpenerIDs", MyQGatewayID)
		-- Lifted from Netatmo credit akbooer
		debug("(MyQGateway::startupDeferred): Processing child devices.",2)
		local child_devices = luup.chdev.start(MyQGatewayID); -- create child devices

		log("(MyQGateway::startupDeferred): Number of devices to process = ["..(#openerInfo or "NIL").."].",2)
		local child_IDs = {} -- Store child IDs so that we can check and not recreate them
		for i = 1, #openerInfo do -- Over the individual openers we go
			log("(MyQGateway::startupDeferred): Processing device ["..(i or "NIL").."] name ["..(openerInfo[i].OpenerName or "NIL").."] data [\n"..(UTIL:dump(openerInfo[i]) or "NIL").."\n].",2)
			if openerInfo[i].DeviceType == "GARAGE_DOOR_OPENER" then
				if ((UTIL:IsUI7() == true) and (PLUGIN_CONFIG.UI7_GDO == true)) then
					luup.chdev.append(MyQGatewayID, -- parent (this device)
						child_devices, -- Pointer from above start call
						openerInfo[i].DeviceId, -- Our child ID taken from the opener device id
						openerInfo[i].OpenerName, -- Child device description
						"urn:schemas-micasaverde-com:device:DoorLock:1", -- deviceType defined in device file
						"D_MyQGarageDoor1.xml", -- Device file
						"", -- No implementation file
						"", -- No parameters to set
						false) -- Not embedded child device (can go in any room)
				else
					luup.chdev.append(MyQGatewayID, -- parent (this device)
						child_devices, -- Pointer from above start call
						openerInfo[i].DeviceId, -- Our child ID taken from the opener device id
						openerInfo[i].OpenerName, -- Child device description
						"urn:schemas-micasaverde-com:device:DoorLock:1", -- deviceType defined in device file
						"D_DoorLock1.xml", -- Device file
						"", -- No implementation file
						"", -- No parameters to set
						false) -- Not embedded child device (can go in any room)
				end
			elseif openerInfo[i].DeviceType == "LIGHT_SWITCH" then
				luup.chdev.append(MyQGatewayID, -- parent (this device)
					child_devices, -- Pointer from above start call
					openerInfo[i].DeviceId, -- Our child ID taken from the opener device id
					openerInfo[i].OpenerName, -- Child device description
					"urn:schemas-upnp-org:device:BinaryLight:1", -- deviceType defined in device file
					"D_BinaryLight1.xml", -- Device file
					"", -- No implementation file
					"", -- No parameters to set
					false) -- Not embedded child device (can go in any room)		
			end
			child_IDs[i] = openerInfo[i].DeviceId
		end
		luup.chdev.sync(MyQGatewayID, child_devices) -- any changes in configuration will cause a restart at this point

		-- Found: http://forum.micasaverde.com/index.php/topic,7458.msg47733.html#msg47733
		-- Probably NOT the way I want to do this but works for now
		child_id_lookup_table = {}
		child_deviceid_lookup_table = {} -- Reverses for looking up by Vera DeviceId
		for k, v in pairs(luup.devices) do
			-- if I am the parent device
			if v.device_num_parent == MyQGatewayID then
				log("child_id_lookup_table["..(v.id or "NIL").."] = "..(k or "NIL"))
				child_id_lookup_table[tonumber(v.id,10)] = k
				log("child_deviceid_lookup_table["..(k or "NIL").."] = "..(v.id or "NIL"))
				child_deviceid_lookup_table[k] = tonumber(v.id,10)
			end
		end

		-- Set the status of the doors
		-- Check that we have anything in child_IDs before trying to save it!
		if (table.getn(child_IDs) > 0) then
			luup.variable_set(MYQGATEWAY_SID, "OpenerIDs", table.concat(child_IDs, ","), MyQGatewayID)
		end
	else
		-- no data returned from the MyQ servers for the device list (no connection?)
		log('(MyQGateway::startupdeferred): No device data retrieved.')
		log("(MyQGateway::startupDeferred): MyQ Gateway Plugin "..version.." - ********** STARTUP COMPLETE **********",1)
		return false
	end
	-- Fire up our timer to check on auth code and door status
	-- periodic refresh of security token, no longer used.

	log('(MyQGateway::startupdeferred): ID for MyQGateway is ' .. MyQGatewayID)
	luup.call_delay('RefreshDevices', 10, "") -- Check the status of the doors on init after 10 seconds
	if (UTIL:IsUI7()) then
		luup.set_failure(0)
	else
		luup.set_failure(false)
	end
	log("(MyQGateway::startupDeferred): MyQ Gateway Plugin "..version.." - ********** STARTUP COMPLETE **********",2)
	return true
end



------------------------------------------------
--
-- Periodic refresh of our device  status
--
------------------------------------------------
function RefreshDevices()
    local refreshInterval = luup.variable_get(MYQGATEWAY_SID, "RefreshInterval", MyQGatewayID)
    if (refreshInterval ~= nil and tonumber(refreshInterval) > 0) then
        luup.call_delay('RefreshDevices', tonumber(refreshInterval), "") -- Check the status of the doors, currently every xx seconds
    else
        luup.variable_set(MYQGATEWAY_SID, "RefreshInterval", 0, MyQGatewayID)
    end
    justRefreshDevices()
end

-----------------------------------------------------------------------
--
-- Actual implementation of garage door and light switch status refresh
--
-----------------------------------------------------------------------


function justRefreshDevices()
		debug("(MyQGateway::justRefreshDevices): Starting status poll process.",2)
		local recheck = false
    local authResult, authText = MYQ_API:retrieveSecurityToken()

    if (authResult == true) then
			SecurityToken = authText
			Timestamp = UTIL:getTimestamp()
			luup.variable_set(MYQGATEWAY_SID, "Timestamp", Timestamp, MyQGatewayID)
			clearTask ()
    else
			local msg = "myQ authorization failed.  Check settings in myQ setup."
			task(msg, TASK_ERROR_PERM)
			log("(MyQGateway::justRefreshDevices): Authorization failed. ("..(authText or "No Text").."). Exiting",1)
			return
    end


    local connectionResult, openerInfo, ParentName, ParentId = MYQ_API:inspectDevices()

    --Check to see if we have a problem
    --But how to fail gracefully and re-check if the URL is perhaps down?
    if (connectionResult == false) then --Try to reauth
			log("(MyQGateway::justRefreshDevices): Error on refreash doors, Exiting.",1)
			return
    end

    -- Get the status of the doors and light switches
		for i = 1, #openerInfo do
			log("(MyQGateway::justRefreshDevices): Processing MyQ device ["..(openerInfo[i].DeviceId or "NIL").."] vera id ["..(child_id_lookup_table[tonumber(openerInfo[i].DeviceId,10)] or "NIL").."].",2)
			if openerInfo[i].DeviceType == "GARAGE_DOOR_OPENER" then
				local deviceOnline, deviceOnlineStatus = MYQ_API:getStatus(openerInfo[i].DeviceId, "online")
				debug("(MyQGateway::justRefreshDevices):     Device ["..(openerInfo[i].DeviceId or "NIL").."] online ["..(deviceOnline and "TRUE" or "FALSE").."].",2)
				if (deviceOnline and ((deviceOnlineStatus == "True") or (deviceOnlineStatus == true) or (deviceOnlineStatus == "1")  or (deviceOnlineStatus == 1))) then
					if (UTIL:IsUI7()) then
						luup.set_failure(0,child_id_lookup_table[openerInfo[i].DeviceId])
					else
						luup.set_failure(false,child_id_lookup_table[openerInfo[i].DeviceId])
					end
					local deviceStatus, deviceStatusText = MYQ_API:getStatus(openerInfo[i].DeviceId, "doorstate")
					if (deviceStatus == true) then
						debug("(MyQGateway::justRefreshDevices):     Device ["..(openerInfo[i].DeviceId or "NIL").."] doorstate ["..(deviceStatusText or "NIL").."].",2)
						local lastStatusText = luup.variable_get(GDO_SID, "Status",  child_id_lookup_table[openerInfo[i].DeviceId])
						if (tonumber(deviceStatusText,10) ~= tonumber(lastStatusText,10)) then
							luup.variable_set("urn:micasaverde-com:SecuritySensor1", "LastTrip", os.time(), child_id_lookup_table[openerInfo[i].DeviceId])
						end
						if (tonumber(deviceStatusText,10) == 2) then -- Closed
							luup.variable_set(GDO_SID, "Status", 1, child_id_lookup_table[openerInfo[i].DeviceId])
						elseif ((tonumber(deviceStatusText,10) == 1) or (tonumber(deviceStatusText,10) == 9)  or (tonumber(deviceStatusText,10) == 3)) then -- Open - mid-stop == open
							luup.variable_set(GDO_SID, "Status", 0, child_id_lookup_table[openerInfo[i].DeviceId])
						else 
							-- the following door states could be trapped in the future...
							--3=mid stop, 4=running up, 5=running down, 7=fault, 8=moving
							if ((UTIL:IsUI7() == true) and (PLUGIN_CONFIG.UI7_GDO == true)) then
								luup.variable_set(GDO_SID, "Status", tonumber(deviceStatusText,10), child_id_lookup_table[openerInfo[i].DeviceId])
								if (PLUGIN_CONFIG.ENHANCED_STATUS) then
									if ((deviceStatusText == "4") or (deviceStatusText == "5") or (deviceStatusText == "8")) then
										-- opener is in the process of changing state
										recheck = true
									end
								end
							else
								task("MyQ Gateway Unexpected Door Status: " .. deviceStatusText, TASK_BUSY)
								log("(MyQGateway::justRefreshDevices): Unexpected Door Status: " .. deviceStatusText,1)
							end
						end
					end
				else
					-- device is offline
					debug("(MyQGateway::justRefreshDevices): Device ["..child_id_lookup_table[openerInfo[i].DeviceId].."]["..openerInfo[i].DeviceId.."]  is OFFLINE",1)
					if (UTIL:IsUI7()) then
						luup.set_failure(1,child_id_lookup_table[openerInfo[i].DeviceId])
					else
						luup.set_failure(true,child_id_lookup_table[openerInfo[i].DeviceId])
					end
					-- set offline door status to opened to attract attention
					if ((UTIL:IsUI7() == true) and (PLUGIN_CONFIG.UI7_GDO == true)) then
						luup.variable_set(GDO_SID, "Status", 10, child_id_lookup_table[openerInfo[i].DeviceId])	-- use Status = 10 for offline
					else
						luup.variable_set(GDO_SID, "Status", 0, child_id_lookup_table[openerInfo[i].DeviceId])
					end
				end
			elseif openerInfo[i].DeviceType == "LIGHT_SWITCH" then
				-- I assume "lightstate" is the correct attribute to get based on inspecting the mychamberlain web app.
				local deviceStatus, deviceStatusText = MYQ_API:getStatus(openerInfo[i].DeviceId, "lightstate")
				if (deviceStatus == true) then
					debug("(MyQGateway::justRefreshDevices):     Device ["..(openerInfo[i].DeviceId or "NIL").."] lightstate ["..(deviceStatusText or "NIL").."].",2)
					if (tonumber(deviceStatusText,10) ~= tonumber(lastStatusText,10)) then
						luup.variable_set("urn:micasaverde-com:SecuritySensor1", "LastTrip", os.time(), child_id_lookup_table[openerInfo[i].DeviceId])
					end
					if (tonumber(deviceStatusText,10) == 1) then -- ON
						luup.variable_set(BINARY_LIGHT_SID, "Status", 1, child_id_lookup_table[openerInfo[i].DeviceId])
					elseif (tonumber(deviceStatusText,10) == 0) then -- OFF
						luup.variable_set(BINARY_LIGHT_SID, "Status", 0, child_id_lookup_table[openerInfo[i].DeviceId])
					else 
						task("MyQ Gateway Unexpected Light Switch Status: " .. deviceStatusText, TASK_BUSY)
						log("(MyQGateway::justRefreshDevices): Unexpected Light Switch Status: " .. deviceStatusText,1)
					end
				end			
			end
    end

    --Use the LastCheck variable to store the last time the doors were checked
    --The timestamp is set for when the last re-auth occurred
    local Timestamp = UTIL:getTimestamp()
    luup.variable_set(MYQGATEWAY_SID, "LastCheck", Timestamp, MyQGatewayID)
		if (recheck) then
			-- Door is in the middle of a cycle - recheck the status of the doors
			luup.call_delay('justRefreshDevices', 5, "")
		end
		debug("(MyQGateway::justRefreshDevices): Poll process completed.",2)
end


 
